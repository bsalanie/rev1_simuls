{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>rev1_simuls</code>","text":"<p>Simulations for revision 1 of Galichon-Salanie for JAppE</p> <ul> <li>Documentation: https://bsalanie.github.io/rev1_simuls</li> </ul>"},{"location":"plots/","title":"<code>plots</code> module","text":""},{"location":"plots/#rev1_simuls.plots.plot_simulation_results","title":"<code>plot_simulation_results(full_model_name, n_households_sim, n_sim, value_coeff, do_simuls_mde=True, do_simuls_poisson=True, n_households_obs=None)</code>","text":"<p>plots the simulation results</p> <p>Parameters:</p> Name Type Description Default <code>full_model_name</code> <code>str</code> <p>the type of model we are estimating</p> required <code>n_households_sim</code> <code>float</code> <p>the number of households in the simulation</p> required <code>n_sim</code> <code>int</code> <p>the number of simulation runs</p> required <code>value_coeff</code> <code>int</code> <p>the divider of the smallest positive mu</p> required <code>do_simuls_mde</code> <code>bool</code> <p>do we simulate the MDE</p> <code>True</code> <code>do_simuls_poisson</code> <code>bool</code> <p>do we simulate Poisson</p> <code>True</code> <code>n_households_obs</code> <code>float</code> <p>the number of observed households in the Cupid dataset</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>rev1_simuls/plots.py</code> <pre><code>def plot_simulation_results(\n    full_model_name: str,  # the type of model we are estimating\n    n_households_sim: float,  # the number of households in the simulation\n    n_sim: int,  # the number of simulation runs\n    value_coeff: int,  # the divider of the smallest positive mu\n    do_simuls_mde: bool = True,  # do we simulate MDE\n    do_simuls_poisson: bool = True,  # do we simulate Poisson\n    n_households_obs: float = None,  # the number of observed households in the Cupid dataset\n) -&gt; None:\n\"\"\"plots the simulation results\n\n    Args:\n        full_model_name: the type of model we are estimating\n        n_households_sim:  the number of households in the simulation\n        n_sim:  the number of simulation runs\n        value_coeff:  the divider of the smallest positive mu\n        do_simuls_mde:  do we simulate the MDE\n        do_simuls_poisson:   do we simulate Poisson\n        n_households_obs: the number of observed households in the Cupid dataset\n\n    Returns:\n        nothing\n    \"\"\"\n    results_file = (\n        results_dir / f\"{full_model_name}_{n_households_sim}_{int(value_coeff)}.pkl\"\n    )\n    with open(results_file, \"rb\") as f:\n        results = pickle.load(f)\n    true_coeffs = results[\"True coeffs\"]\n    n_bases = true_coeffs.size\n    if full_model_name.startswith(\"choo_siow_cupid\"):\n        varcov_coeffs = results[\"Cupid varcov\"]\n        varcov_rescaled = varcov_coeffs * n_households_obs / n_households_sim\n\n    base_names = results[\"Base names\"]\n\n    outliers_mask = [False] * n_sim\n    if do_simuls_mde:\n        estim_mde = results[\"MDE\"]\n        outliers_mde = _discard_outliers(estim_mde, \"MDE\", nstd=4.0)\n        outliers_mask = outliers_mask | outliers_mde\n    if do_simuls_poisson:\n        estim_poisson = results[\"Poisson\"]\n        outliers_poisson = _discard_outliers(estim_poisson, \"Poisson\", nstd=4.0)\n        outliers_mask = outliers_mask | outliers_poisson\n\n    kept = [True] * n_sim\n    if any(outliers_mask):\n        n_discards = 0\n        for i in range(n_sim):\n            if outliers_mask[i]:\n                kept[i] = False\n                n_discards += 1\n        print(f\"We are discarding {n_discards} outlier samples\")\n    else:\n        print(\"We have found no outlier samples\")\n\n    if full_model_name.startswith(\"choo_siow_cupid\"):\n        rng = np.random.default_rng(67569)\n        n_kept = len(kept)\n        expected = np.zeros((n_kept, n_bases))\n        for i_sim in range(n_kept):\n            expected[i_sim, :] = rng.multivariate_normal(\n                mean=true_coeffs, cov=varcov_rescaled\n            )\n        estims = [expected]\n        if do_simuls_mde:\n            estims.append(estim_mde)\n            if do_simuls_poisson:\n                estims.append(estim_poisson)\n        elif do_simuls_poisson:\n            estims.append(estim_poisson)\n    else:\n        if do_simuls_mde:\n            estims = estim_mde\n            if do_simuls_poisson:\n                estims.append(estim_poisson)\n        elif do_simuls_poisson:\n            estims = estim_poisson\n\n    df_simul_results = _dataframe_results(\n        full_model_name,\n        base_names,\n        estims,\n        do_simuls_mde=do_simuls_mde,\n        do_simuls_poisson=do_simuls_poisson,\n    )\n\n    g = sns.FacetGrid(\n        data=df_simul_results,\n        sharex=False,\n        sharey=False,\n        hue=\"Estimator\",\n        col=\"Parameter\",\n        col_wrap=2,\n    )\n    g.map(sns.kdeplot, \"Estimate\")\n    #     g.set_xlim([-1.0, 3.0])\n    g.set_titles(\"{col_name}\")\n    for true_val, ax in zip(true_coeffs, g.axes.ravel()):\n        ax.vlines(true_val, *ax.get_ylim(), color=\"k\", linestyles=\"dashed\")\n    g.add_legend()\n\n    plt.savefig(\n        results_dir\n        / f\"{full_model_name}_simul_{n_households_sim}_{int(value_coeff)}.png\"\n    )\n</code></pre>"},{"location":"read_data/","title":"<code>read_data</code> module","text":""},{"location":"read_data/#rev1_simuls.read_data.ages_slice","title":"<code>ages_slice(age_start, age_end)</code>","text":"<p>returns the corresponding slice</p> Source code in <code>rev1_simuls/read_data.py</code> <pre><code>def ages_slice(\n    age_start: int,\n    age_end: int,\n) -&gt; slice:\n\"\"\"returns the corresponding slice\"\"\"\n    age0, age1 = age_start - 16, age_end - 15\n    return slice(age0, age1)\n</code></pre>"},{"location":"read_data/#rev1_simuls.read_data.read_margins","title":"<code>read_margins(data_dir, age_start=16, age_end=40)</code>","text":"<p>reads and returns the margins for men and for women</p> Source code in <code>rev1_simuls/read_data.py</code> <pre><code>def read_margins(\n    data_dir: Path,  # the data directory\n    age_start: Optional[int] = 16,  # we exclude younger ages\n    age_end: Optional[int] = 40,  # we exclude older ages\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"reads and returns the margins for men and for women\"\"\"\n    nx = np.loadtxt(data_dir / \"nx70n.txt\")\n    my = np.loadtxt(data_dir / \"my70n.txt\")\n    ages = ages_slice(age_start, age_end)\n    return nx[ages], my[ages]\n</code></pre>"},{"location":"read_data/#rev1_simuls.read_data.read_marriages","title":"<code>read_marriages(data_dir, age_start=16, age_end=40)</code>","text":"<p>reads and returns the marriages and the variances</p> Source code in <code>rev1_simuls/read_data.py</code> <pre><code>def read_marriages(\n    data_dir: Path,  # the data directory\n    age_start: Optional[int] = 16,  # we exclude younger ages\n    age_end: Optional[int] = 40,  # we exclude older ages\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"reads and returns the marriages and the variances\"\"\"\n    muxy = np.loadtxt(data_dir / \"muxy70nN.txt\")\n    varmus = np.loadtxt(data_dir / \"varmus70nN.txt\")\n    vmus = varmus_select_ages(varmus, age_start, age_end)\n    ages = ages_slice(age_start, age_end)\n    return muxy[ages, ages], vmus\n</code></pre>"},{"location":"read_data/#rev1_simuls.read_data.remove_zero_cells","title":"<code>remove_zero_cells(mus, coeff=100)</code>","text":"<p>if <code>coeff</code> is not 0, add small number <code>delta</code> to 0-cells to avoid numerical issues</p> Source code in <code>rev1_simuls/read_data.py</code> <pre><code>def remove_zero_cells(\n    mus: Matching,  # muxy, mux0, mu0y, n, m\n    coeff: int = 100,  # default scale factor for delta\n) -&gt; Matching:  # the transformed muxy, mux0, mu0y, nx, my\n\"\"\"if `coeff` is not 0, add small number `delta` to 0-cells to avoid numerical issues\"\"\"\n    muxy, mux0, mu0y, *_ = mus.unpack()\n    zeros_muxy, muxy_size, min_muxy = _get_zeros_mu(muxy)\n    zeros_mux0, mux0_size, min_mux0 = _get_zeros_mu(mux0)\n    zeros_mu0y, mu0y_size, min_mu0y = _get_zeros_mu(mu0y)\n    some_zeros = zeros_muxy or zeros_mux0 or zeros_mu0y\n    if not some_zeros or coeff == 0:\n        return mus\n    else:\n        delta = min(min_muxy, min_mux0, min_mu0y) / coeff\n        muxy_fixed = muxy.astype(float)\n        mux0_fixed = mux0.astype(float)\n        mu0y_fixed = mu0y.astype(float)\n        n_cells = 0\n        if zeros_muxy:\n            muxy_fixed += delta\n            n_cells += muxy_size\n        if zeros_mux0:\n            mux0_fixed += delta\n            n_cells += mux0_size\n        if zeros_mu0y:\n            mu0y_fixed += delta\n            n_cells += mu0y_size\n        n_households = np.sum(muxy) + np.sum(mux0) + np.sum(mu0y)\n        scale_factor = n_households / (n_households + delta * n_cells)\n        muxy_fixed *= scale_factor\n        mux0_fixed *= scale_factor\n        mux0_fixed *= scale_factor\n        nx_fixed, my_fixed = _compute_margins(muxy_fixed, mux0_fixed, mu0y_fixed)\n        mus_fixed = Matching(muxy_fixed, nx_fixed, my_fixed)\n        return mus_fixed\n</code></pre>"},{"location":"read_data/#rev1_simuls.read_data.rescale_mus","title":"<code>rescale_mus(mus, n_households)</code>","text":"<p>normalizes the marriages and margins to a requested total number of households</p> Source code in <code>rev1_simuls/read_data.py</code> <pre><code>def rescale_mus(\n    mus: Matching,  # muxy, mux0, mu0y\n    n_households: float,  # the number of households we want\n) -&gt; Matching:  # the normalized Matching after rescaling\n\"\"\"normalizes the marriages and margins to a requested total number of households\"\"\"\n    muxy, mux0, mu0y, nx, my = mus.unpack()\n    n_households_mus = np.sum(muxy) + np.sum(mux0) + np.sum(mu0y)\n    rescale_factor = n_households / n_households_mus\n    muxy_norm = muxy * rescale_factor\n    nx_norm = nx * rescale_factor\n    my_norm = my * rescale_factor\n    mus_norm = Matching(muxy_norm, nx_norm, my_norm)\n    return mus_norm\n</code></pre>"},{"location":"read_data/#rev1_simuls.read_data.reshape_varcov","title":"<code>reshape_varcov(varmus, mus, n_households)</code>","text":"<p>splits the variance-covariance matrix and renormalizes for a requested total number of households</p> <p>Parameters:</p> Name Type Description Default <code>varmus</code> <code>np.ndarray</code> <p>muxy row major, then  mux0, then mu0y packed in both dimensions</p> required <code>mus</code> <code>Matching</code> <p>the original Matching</p> required <code>n_households</code> <code>float</code> <p>the number of households we want</p> required <p>Returns:</p> Type Description <code>tuple[np.ndarray]</code> <p>the 6 constituent blocks of the normalized variance-covariance</p> Source code in <code>rev1_simuls/read_data.py</code> <pre><code>def reshape_varcov(\n    varmus: np.ndarray,\n    mus: Matching,\n    n_households: float,\n) -&gt; tuple[np.ndarray]:\n\"\"\"splits the variance-covariance matrix\n    and renormalizes for a requested total number of households\n\n    Args:\n        varmus:  muxy row major, then  mux0, then mu0y packed in both dimensions\n        mus: the original Matching\n        n_households:  the number of households we want\n\n    Returns:\n         the 6 constituent blocks of the normalized variance-covariance\n    \"\"\"\n    muxy, mux0, mu0y, *_ = mus.unpack()\n    ncat_men, ncat_women = muxy.shape\n    n_prod_categories = ncat_men * ncat_women\n    # first we reshape\n    varmus_xyzt = varmus[:n_prod_categories, :n_prod_categories]\n    varmus_xyz0 = varmus[\n        :n_prod_categories, n_prod_categories : (n_prod_categories + ncat_men)\n    ]\n    varmus_xy0t = varmus[:n_prod_categories, (n_prod_categories + ncat_men) :]\n    varmus_x0z0 = varmus[\n        n_prod_categories : (n_prod_categories + ncat_men),\n        n_prod_categories : (n_prod_categories + ncat_men),\n    ]\n    varmus_x00y = varmus[\n        n_prod_categories : (n_prod_categories + ncat_men),\n        (n_prod_categories + ncat_men) :,\n    ]\n    varmus_0y0t = varmus[\n        (n_prod_categories + ncat_men) :, (n_prod_categories + ncat_men) :\n    ]\n    varcovs = (\n        varmus_xyzt,\n        varmus_xyz0,\n        varmus_xy0t,\n        varmus_x0z0,\n        varmus_x00y,\n        varmus_0y0t,\n    )\n    # then we rescale\n    n_households_mus = np.sum(muxy) + np.sum(mux0) + np.sum(mu0y)\n    rescale_factor = n_households / n_households_mus\n    rescale_factor2 = rescale_factor * rescale_factor\n    varcovs = tuple(v * rescale_factor2 for v in varcovs)\n    return varcovs\n</code></pre>"},{"location":"read_data/#rev1_simuls.read_data.varmus_select_ages","title":"<code>varmus_select_ages(varmus, age_start, age_end)</code>","text":"<p>extracts the age-appropriate part of varmus</p> Source code in <code>rev1_simuls/read_data.py</code> <pre><code>def varmus_select_ages(\n    varmus: np.ndarray,\n    age_start: int,\n    age_end: int,\n) -&gt; np.ndarray:\n\"\"\"extracts the age-appropriate part of varmus\"\"\"\n    if (age_start &gt; 16) or (age_end &lt; 40):\n        nages = 25\n        nages2 = nages * nages\n        nb_ages = age_end - age_start + 1\n        nb_ages2 = nb_ages * nb_ages\n        vmus_dim = nb_ages2 + nb_ages + nb_ages\n        vmus = np.zeros((vmus_dim, vmus_dim))\n        age0, age1 = age_start - 16, age_end - 15\n        for x1 in range(nb_ages):\n            ox1 = x1 + age0\n            for y1 in range(nb_ages):\n                oy1 = y1 + age0\n                varmus1 = varmus[ox1 * nages + oy1, :]\n                vmus1 = np.zeros(vmus_dim)\n                for x2 in range(nb_ages):\n                    ox2 = x2 + age0\n                    vmus1[(x2 * nb_ages) : (x2 * nb_ages + nb_ages)] = varmus1[\n                        (ox2 * nages + age0) : (ox2 * nages + age1)\n                    ]\n                    vmus1[nb_ages2 : (nb_ages2 + nb_ages)] = varmus1[\n                        (nages2 + age0) : (nages2 + age1)\n                    ]\n                    vmus1[(nb_ages2 + nb_ages) :] = varmus1[\n                        (nages2 + nages + age0) : (nages2 + nages + age1)\n                    ]\n                    vmus[x1 * nb_ages + y1, :] = vmus1\n        for x in range(nb_ages):\n            ox = x + age0\n            vmus[nb_ages2 + x, nb_ages2 : (nb_ages2 + nb_ages)] = varmus[\n                nages2 + ox, (nages2 + age0) : (nages2 + age1)\n            ]\n            vmus[nb_ages2 + x, (nb_ages2 + nb_ages) :] = varmus[\n                nages2 + ox, (nages2 + nages + age0) : (nages2 + nages + age1)\n            ]\n        for y in range(nb_ages):\n            vmus[nb_ages2 + nb_ages + y, (nb_ages2 + nb_ages) :] = varmus[\n                nages2 + nages + ox,\n                (nages2 + nages + age0) : (nages2 + nages + age1),\n            ]\n        vmus[nb_ages2 : (nb_ages2 + nb_ages), :nb_ages2] = vmus[\n            :nb_ages2, nb_ages2 : (nb_ages2 + nb_ages)\n        ].T\n        vmus[(nb_ages2 + nb_ages) :, :nb_ages2] = vmus[\n            :nb_ages2, (nb_ages2 + nb_ages) :\n        ].T\n        vmus[(nb_ages2 + nb_ages) :, nb_ages2 : (nb_ages2 + nb_ages)] = vmus[\n            nb_ages2 : (nb_ages2 + nb_ages), (nb_ages2 + nb_ages) :\n        ].T\n        return vmus\n    else:\n        return varmus\n</code></pre>"},{"location":"specification/","title":"<code>specification</code> module","text":""},{"location":"specification/#rev1_simuls.specification.generate_bases","title":"<code>generate_bases(nx, my, degrees)</code>","text":"<p>generates the bases for a semilinear specification</p> <p>Parameters:</p> Name Type Description Default <code>nx</code> <code>np.ndarray</code> <p>the numbers of men of each type</p> required <code>my</code> <code>np.ndarray</code> <p>the numbers of women of each type</p> required <code>degrees</code> <code>List[Tuple[int, int]]</code> <p>the list of degrees for polynomials in <code>x</code> and <code>y</code></p> required <p>Returns:</p> Type Description <code>Tuple[np.ndarray, List[str]]</code> <p>the matrix of base functions and their names</p> Source code in <code>rev1_simuls/specification.py</code> <pre><code>def generate_bases(\n    nx: np.ndarray,\n    my: np.ndarray,\n    degrees: List[Tuple[int, int]],\n) -&gt; Tuple[np.ndarray, List[str]]:\n\"\"\"generates the bases for a semilinear specification\n\n    Args:\n        nx: the numbers of men of each type\n        my: the numbers of women of each type\n        degrees: the list of degrees for polynomials in `x` and `y`\n\n    Returns:\n         the matrix of base functions and their names\n    \"\"\"\n    n_bases = 3 + len(degrees)\n    n_types_men, n_types_women = nx.size, my.size\n    types_men, types_women = np.arange(n_types_men), np.arange(n_types_women)\n    base_funs = np.zeros((n_types_men, n_types_women, n_bases))\n    base_names = [None] * n_bases\n    base_funs[:, :, 0] = 1.0\n    base_names[0] = \"1\"\n    for y in types_women:\n        base_funs[:, y, 1] = np.where(types_men &gt; y, 1.0, 0.0)\n        base_funs[:, y, 2] = np.where(types_men &gt; y, types_men - y, 0)\n    base_funs[:, :, 2] /= (n_types_men + n_types_women) / 2\n    base_names[1] = \"1(x&gt;y)\"\n    base_names[2] = \"max(x-y,0)\"\n    # we quantile-transform nx and my\n    q_nx = quantile_transform(nx)\n    q_my = quantile_transform(my)\n    # and we use the Legendre polynomials on [0,1]\n    max_deg_x = max(degree[0] for degree in degrees)\n    max_deg_y = max(degree[1] for degree in degrees)\n    polys_x = legendre_polynomials(q_nx, max_deg_x, a=0)\n    polys_y = legendre_polynomials(q_my, max_deg_y, a=0)\n    i_base = 3\n    for deg_x, deg_y in degrees:\n        poly_x = polys_x[:, deg_x]\n        poly_y = polys_y[:, deg_y]\n        base_funs[:, :, i_base] = np.outer(poly_x, poly_y)\n        base_names[i_base] = f\"x^{deg_x} * y^{deg_y}\"\n        i_base += 1\n    return base_funs, base_names\n</code></pre>"},{"location":"utils/","title":"<code>utils</code> module","text":""},{"location":"utils/#rev1_simuls.utils.legendre_polynomials","title":"<code>legendre_polynomials(x, max_deg, a=-1.0, b=1.0, no_constant=False)</code>","text":"<p>evaluates the Legendre polynomials over x in the interval [a, b]</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>the points where the polynomials are to be evaluated</p> required <code>max_deg</code> <code>int</code> <p>the maximum degree</p> required <code>a</code> <code>float</code> <p>the start of the interval, classically -1</p> <code>-1.0</code> <code>b</code> <code>float</code> <p>the end of the interval, classically 1</p> <code>1.0</code> <code>no_constant</code> <code>bool</code> <p>if True, delete the constant polynomial</p> <code>False</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>an array of (max_deg+1) arrays of the shape of x</p> Source code in <code>rev1_simuls/utils.py</code> <pre><code>def legendre_polynomials(\n    x: np.ndarray,\n    max_deg: int,\n    a: float = -1.0,\n    b: float = 1.0,\n    no_constant: bool = False,\n) -&gt; np.ndarray:\n\"\"\"evaluates the Legendre polynomials over x in the interval [a, b]\n\n    Args:\n        x: the points where the polynomials are to be evaluated\n        max_deg: the maximum degree\n        a: the start of the interval, classically -1\n        b: the end of the interval, classically 1\n        no_constant: if True, delete the constant polynomial\n\n    Returns:\n        an array of (max_deg+1) arrays of the shape of x\n    \"\"\"\n    if a &gt; np.min(x):\n        sys.exit(\"legendre_polynomials: points below start of interval\")\n    if b &lt; np.max(x):\n        sys.exit(\"legendre_polynomials: points above end of interval\")\n    p = np.zeros((x.size, max_deg + 1))\n    x_transf = 2.0 * (x - a) / (b - a) - 1.0\n    p[:, 0] = np.ones_like(x)\n    p[:, 1] = x_transf\n    for deg in range(2, max_deg + 1):\n        p2 = (2 * deg - 1) * (p[:, deg - 1] * x_transf) - (deg - 1) * p[:, deg - 2]\n        p[:, deg] = p2 / deg\n    polys_p = p[:, 1:] if no_constant else p\n    return polys_p\n</code></pre>"},{"location":"utils/#rev1_simuls.utils.nprepeat_col","title":"<code>nprepeat_col(v, n)</code>","text":"<p>create a matrix with <code>n</code> columns equal to the vector <code>v</code></p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>np.ndarray</code> <p>a 1-dim array of size <code>m</code></p> required <code>n</code> <code>int</code> <p>the number of columns requested</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>a 2-dim array of shape <code>(m, n)</code></p> Source code in <code>rev1_simuls/utils.py</code> <pre><code>def nprepeat_col(\n    v: np.ndarray,\n    n: int,\n) -&gt; np.ndarray:\n\"\"\"create a matrix with `n` columns equal to the vector `v`\n\n    Args:\n        v: a 1-dim array of size `m`\n        n:  the number of columns requested\n\n    Returns:\n        a 2-dim array of shape `(m, n)`\n    \"\"\"\n    return np.repeat(v[:, np.newaxis], n, axis=1)\n</code></pre>"},{"location":"utils/#rev1_simuls.utils.nprepeat_row","title":"<code>nprepeat_row(v, m)</code>","text":"<p>create a matrix with <code>m</code> rows equal to the vector <code>v</code></p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>np.ndarray</code> <p>a 1-dim array of size <code>n</code></p> required <code>n</code> <p>the number of rows requested</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>a 2-dim array of shape <code>(m, n)</code></p> Source code in <code>rev1_simuls/utils.py</code> <pre><code>def nprepeat_row(\n    v: np.ndarray,\n    m: int,\n) -&gt; np.ndarray:\n\"\"\"create a matrix with `m` rows equal to the vector `v`\n\n    Args:\n        v: a 1-dim array of size `n`\n        n:  the number of rows requested\n\n    Returns:\n        a 2-dim array of shape `(m, n)`\n    \"\"\"\n    return np.repeat(v[np.newaxis, :], m, axis=0)\n</code></pre>"},{"location":"utils/#rev1_simuls.utils.quantile_transform","title":"<code>quantile_transform(v)</code>","text":"<p>transform a vector of counts into the corresponding quantiles</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>np.ndarray</code> <p>a vector of counts</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>the corresponding quantiles</p> Source code in <code>rev1_simuls/utils.py</code> <pre><code>def quantile_transform(v: np.ndarray) -&gt; np.ndarray:\n\"\"\"transform a vector of counts into the corresponding quantiles\n\n    Args:\n        v:  a vector of counts\n\n    Returns:\n         the corresponding quantiles\n    \"\"\"\n    n = v.size\n    q = np.zeros(n)\n    for i in range(n):\n        q[i] = np.sum(v &lt;= v[i]) / (n + 1)\n    return q\n</code></pre>"}]}